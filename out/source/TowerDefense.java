/* autogenerated by Processing revision 1282 on 2023-06-17 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TowerDefense extends PApplet {

//CONSTANTS
final int TOWER_SIZE = 25, RANGE = 200, SHOP_BUTTON_R = 50, PATH_WIDTH = 40, MENU_WIDTH = 200, ENEMY_SIZE = 50, ENEMY_MAX_HEALTH = 10;
final float ENEMY_BASE_SPEED = 1.5f;
final int RADIUS_COLOR = color(200, 200, 200, 50), PATH_COLOR = color(192, 196, 179), MENU_COLOR = 0xFFC98200, BASE_TOWER_COLOR = color(150, 255, 255);

boolean placingTower, towerSelected;
int lives, towerSelectedIndex;

Path path;
PImage background;

final Enemy[] possibleEnemies = {
  new Enemy(5),
  new Enemy(1)
};

final BaseTower[] possibleTowers = {
  new DartMonkey()
};

ArrayList<Enemy> spawnedEnemies = new ArrayList<Enemy>();
ArrayList<BaseTower> purchasedTowers = new ArrayList<BaseTower>();

 public void setup() {
  /* size commented out by preprocessor */;
  path = new Path();
  lives = 250;
  background = loadImage("MonkeyMeadow.png");
  background.resize(width - MENU_WIDTH, height);
}

 public void draw() {
  //draw background
  //background(100, 201, 63);
  image(background, 0, 0);
  
  //DEBUG:
  //path.display();
  fill(0);
  textSize(30);
  textAlign(CENTER);
  text("LIVES: " + lives, 170, 50);
  fill(255, 255, 0);
  text(PApplet.parseInt(frameRate), width - MENU_WIDTH - 50, 50);
  if(purchasedTowers.size() > 0){
    for(int i = 0; i < purchasedTowers.size(); i++){
      text("TARGET: " + purchasedTowers.get(i).target, purchasedTowers.get(i).pos.x, purchasedTowers.get(i).pos.y + 50);
    }
  }
  
  displayShop();
  
  runTowersEnemies();
}

 public void keyReleased() {
  spawnedEnemies.add(possibleEnemies[PApplet.parseInt(random(possibleEnemies.length))].copy());
}

 public void mouseClicked() {
  //BaseTower toAdd = new BaseTower(1, 1, 1, RANGE, 200);
  //toAdd.pos.x = mouseX;
  //toAdd.pos.y = mouseY;
  //towers.add(toAdd);
  
  if(mouseX < width - MENU_WIDTH){
    
  }
  
}

 public void displayShop(){
  noStroke();
  fill(MENU_COLOR);
  rect(width-MENU_WIDTH, 0, MENU_WIDTH, height);
  strokeWeight(1);
  fill(BASE_TOWER_COLOR);
  circle(width-SHOP_BUTTON_R * 2, 50 + SHOP_BUTTON_R, SHOP_BUTTON_R * 2);
}

 public void runTowersEnemies(){
  //calculate towers
  for(int i = 0; i < purchasedTowers.size(); i++){
    purchasedTowers.get(i).run();
  }

  //calculate enemies
  for (int i = 0; i < spawnedEnemies.size(); i++) {
    spawnedEnemies.get(i).run();
    if (spawnedEnemies.get(i).end) {
      lives -= spawnedEnemies.get(i).dmg;
      spawnedEnemies.remove(i);
      continue;
    }
    if (spawnedEnemies.get(i).health < 1) {
      spawnedEnemies.remove(i);
      continue;
    }
  }
  
  //display both
  for (int i = 0; i < spawnedEnemies.size(); i++) {
    spawnedEnemies.get(i).display();
  }
  for(int i = 0; i < purchasedTowers.size(); i++){
    purchasedTowers.get(i).display(); 
  }
}
class BaseTower {
  boolean beingPlaced, selected, inMenu;
  int dmg, pierce, projWidth, tSize, range, cost, dmgCount;
  float fireRate;
  int towerColor;

  PVector pos;
  Enemy target;

  BaseTower(int dmg, int pierce, int projWidth, int range, int cost) {
    this.dmg = dmg;
    this.pierce = pierce;
    this.projWidth = projWidth;
    this.range = range;
    this.cost = cost;
    tSize = TOWER_SIZE;
    pos = new PVector(0, 0);
    towerColor = BASE_TOWER_COLOR;
  }

   public void run() {
    target = getTarget();
  }
  
    public void display() {
    //text("target: " + target, 200, 200);
    //text("delayTimer: " + delayTimer, 200, 230);
    //text("projectiles: " + projectiles.size(), 200, 260);

    //for (int i = 0; i < projectiles.size(); i++) {
    //  projectiles.get(i).display();
    //}
    if (selected) {
      fill(RADIUS_COLOR);
      noStroke();
      circle(pos.x, pos.y, RANGE * 2);
    }
    fill(towerColor);
    strokeWeight(1);
    stroke(0);
    circle(pos.x, pos.y, tSize * 2);
  }

   public Enemy getTarget() {
    Enemy[] inRange = new Enemy[spawnedEnemies.size()];
    int counter = 0;
    for (int i = 0; i < spawnedEnemies.size(); i++) {
      if (dist(spawnedEnemies.get(i).pos.x, spawnedEnemies.get(i).pos.y, pos.x, pos.y) < range) {
        inRange[counter] = spawnedEnemies.get(i);
        counter++;
      }
    }
    
    if (counter == 0) return null;
    if (counter == 1) return inRange[0];
    
    //else return target with largest prog value
    float maxProg = 0;
    int maxProgIndex = 0;
    for(int i = 0; i < counter; i++){
      if(inRange[i].prog > maxProg){
        maxProg = inRange[i].prog;
        maxProgIndex = i;
      }
    }
    return inRange[maxProgIndex];
  }
  
   public BaseTower copy(){
    return new BaseTower(dmg, pierce, projWidth, range, cost);
  }
}
class DartMonkey extends BaseTower{
  DartMonkey(){
    super(1, 2, 3, 180, 250);
  }
}
class Enemy {
  int dmg, size, health;
  float prog, spd;
  PVector pos;
  boolean end;

  Enemy(int health) {
    this.health = health;
    dmg = health;
    spd = ENEMY_BASE_SPEED + dmg * 0.5f;
    prog = 0;
    size = ENEMY_SIZE;
    end = false;

    pos = new PVector(0, 0);
  }

   public void run() {
    prog += spd;
    calculatePos();
  }

   public void display() {
    stroke(255);
    strokeWeight(2);
    fill(255, 255 * (PApplet.parseFloat(health) / ENEMY_MAX_HEALTH), 120 + 135 * (PApplet.parseFloat(health) / ENEMY_MAX_HEALTH));
    circle(pos.x, pos.y, size - 2);
    fill(255, 0, 0);
    //text(health, pos.x, pos.y - 2 * size / 3);
    text(this.toString().substring(this.toString().length() - 3), pos.x, pos.y - 2 * size / 3);
  }

   public void calculatePos() {
    float mprog = prog;
    int pathCounter = 0;
    while (mprog > path.lengths[pathCounter]) {
      mprog -= path.lengths[pathCounter];
      pathCounter++;
      if (pathCounter == path.lengths.length) {
        end = true;
        return;
      }
    }
    //mprog is progess along its current path between two points
    pos.x = (mprog / path.lengths[pathCounter]) * (path.points[pathCounter+1][0] - path.points[pathCounter][0]) + path.points[pathCounter][0];
    pos.y = (mprog / path.lengths[pathCounter]) * (path.points[pathCounter+1][1] - path.points[pathCounter][1]) + path.points[pathCounter][1];
  }
  
   public Enemy copy(){
    return new Enemy(health);
  }
}
class Path { //a series of points that makes up the vertices of a path (straight line connections)
  int[][] points = {
    {-100, 330},
    {610, 330},
    {610, 150},
    {400, 150},
    {400, 630},
    {200, 630},
    {200, 450},
    {780, 450},
    {780, 270},
    {910, 270},
    {910, 560},
    {540, 560},
    {540, height+100}
  };

  int[] lengths = new int[points.length-1];

  Path() {
    for (int i = 0; i < points.length-1; i++) {
      lengths[i] = PApplet.parseInt(dist(points[i][0], points[i][1], points[i+1][0], points[i+1][1]));
    }
  }

   public void display() {
    strokeWeight(PATH_WIDTH);
    stroke(PATH_COLOR);
    for (int i = 0; i < points.length-1; i++) {
      line(points[i][0], points[i][1], points[i+1][0], points[i+1][1]);
    }
  }
}
class ShopButton{
  int cost;
  
  BaseTower tower;
  PVector pos;
  
  ShopButton(BaseTower tower, int x, int y){
    this.tower = tower;
    pos = new PVector(x, y);
  }
  
   public void display(){
    
  }
}


  public void settings() { size(1420, 780); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TowerDefense" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
