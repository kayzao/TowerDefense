/* autogenerated by Processing revision 1282 on 2023-06-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TowerDefense extends PApplet {

//CONSTANTS
final int TOWER_SIZE = 25, TOWER_FOOTPRINT = 15, TOWER_RANGE = 200, INVALID_DELAY = 300,
  PROJ_SIZE = 10, PROJ_RANGE = 850, PROJ_SPD = 35,
  SHOP_BUTTON_SIZE = 90, PATH_WIDTH = 50, MENU_WIDTH = 200,
  ENEMY_SIZE = 50, ENEMY_HITBOX = 30, ENEMY_MAX_HEALTH = 10,
  FRAMERATE = 60;
final float ENEMY_BASE_SPEED = 1.5f;
final int RADIUS_COLOR = color(100, 100, 100, 50), INVALID_COLOR = color(255, 0, 0, 50), PLACING_COLOR = color(255, 255, 255, 50), PATH_COLOR = color(192, 196, 179), MENU_COLOR = 0xFFC98200, BASE_TOWER_COLOR = color(150, 255, 255);

boolean placingTower, towerSelected;
int lives, towerSelectedIndex, money;

Path path;
PImage background;
BaseTower tempTower;

final Enemy[] possibleEnemies = {
  new Enemy(5),
  new Enemy(1)
};

final BaseTower[] possibleTowers = {
  new DartMonkey(),
  new DartMonkey(),
  new DartMonkey(),
  new DartMonkey(),
  new DartMonkey()
};

ShopButton[] shopButtons = new ShopButton[possibleTowers.length];

ArrayList<Enemy> spawnedEnemies = new ArrayList<Enemy>();
ArrayList<BaseTower> purchasedTowers = new ArrayList<BaseTower>();

 public void setup() {
  frameRate(FRAMERATE);
  /* size commented out by preprocessor */;
  lives = 250;
  placingTower = false;
  towerSelected = false;
  towerSelectedIndex = -1;
  path = new Path();

  background = loadImage("MonkeyMeadow.png");
  background.resize(width - MENU_WIDTH, height);

  for (int i = 0; i < shopButtons.length; i++) {
    shopButtons[i] = new ShopButton(possibleTowers[i].copy(), width - MENU_WIDTH + 5 + (i % 2) * (SHOP_BUTTON_SIZE + 5), 5 + (i / 2) * (SHOP_BUTTON_SIZE + 5), possibleTowers[i].cost, SHOP_BUTTON_SIZE, SHOP_BUTTON_SIZE);
    shopButtons[i].tower.pos = new PVector(shopButtons[i].pos.x + SHOP_BUTTON_SIZE / 2, shopButtons[i].pos.y + SHOP_BUTTON_SIZE / 2);
    shopButtons[i].tower.tSize = SHOP_BUTTON_SIZE / 2 - 8;
  }

  //DEBUG
  money = 1000;
}

 public void draw() {
  //draw background
  //background(100, 201, 63);
  image(background, 0, 0);

  //DEBUG:
  //path.display();

  fill(0);
  textSize(30);
  text("LIVES: " + lives, 210, 50);
  text("MONEY: " + money, 210, 75);
  fill(255, 255, 0);
  text(PApplet.parseInt(frameRate), width - MENU_WIDTH - 50, 50);
  //if (purchasedTowers.size() > 0) {
  //  for (int i = 0; i < purchasedTowers.size(); i++) {
  //    text("TARGET: " + purchasedTowers.get(i).target, purchasedTowers.get(i).pos.x, purchasedTowers.get(i).pos.y + 50);
  //  }
  //}

  runTowersEnemies();

  if (placingTower) {
    tempTower.run();
    tempTower.display();
    tempTower.displayRadius();
  }

  runShop();
}

 public void keyReleased() {
  spawnedEnemies.add(possibleEnemies[PApplet.parseInt(random(possibleEnemies.length))].copy());
}

 public void mouseClicked() {
  checkMousePressed();
}

 public void checkMousePressed() {
  //if (!mousePressed) return;
  if (placingTower) {
    checkPlacingTower();
    return;
  }
  if (towerSelected && mouseX > width - MENU_WIDTH) {
    towerSelected = false;
    if (towerSelectedIndex != -1) {
      purchasedTowers.get(towerSelectedIndex).selected = false;
      towerSelectedIndex = -1;
    }
  } else if (mouseX <= width - MENU_WIDTH) {
    //check if mouse is selecting a tower
    //if(purchasedTowers.size() > 0){
    //  println(towerSelectedIndex + " " + towerSelected + " " + frameCount);
    //}
    for (int i = 0; i < purchasedTowers.size(); i++) {
      if (dist(mouseX, mouseY, purchasedTowers.get(i).pos.x, purchasedTowers.get(i).pos.y) <= purchasedTowers.get(i).tSize) { //if mouse is clicking on a tower
        //println(towerSelected + " " + i + " " + towerSelectedIndex);
        if (towerSelected && i == towerSelectedIndex) { //if it clicks on already selected tower
          towerSelectedIndex = -1;
          towerSelected = false;
          purchasedTowers.get(i).selected = false;
          return;
        } else {
          if (towerSelected) {
            purchasedTowers.get(towerSelectedIndex).selected = false;
          }
          towerSelected = true;
          towerSelectedIndex = i;
          purchasedTowers.get(i).selected = true;
          return;
        }
      }
    }
    //mouse doesnt selected tower
    towerSelected = false;
    if (towerSelectedIndex != -1) {
      purchasedTowers.get(towerSelectedIndex).selected = false;
      towerSelectedIndex = -1;
    }
  }
}

 public void checkPlacingTower() {
  if (mouseX > width - MENU_WIDTH) {
    //cancel buying of tower
    placingTower = false;
    tempTower = null;
  } else {
    //check to make sure its not being blocked by other towers or path
    if (!CheckTowerInPath(tempTower)) {
      for (BaseTower t : purchasedTowers) {
        if (dist(t.pos.x, t.pos.y, tempTower.pos.x, tempTower.pos.y) <= t.footprint + tempTower.footprint) { //inside tower
          tempTower.invalidTime = millis();
          return;
        }
      }
      //PURCHASE COMPLETE
      money -= tempTower.cost;
      purchasedTowers.add(tempTower.copy());
      placingTower = false;
      towerSelected = true;
      towerSelectedIndex = purchasedTowers.size() - 1;
    } else {
      tempTower.invalidTime = millis();
    }
  }
}

 public boolean CheckTowerInPath(BaseTower t) {
  BaseTower temp = t.copy();
  for (int i = 0; i < path.lengths.length; i++) {
    float distance = pointSegmentDistance(new PVector(path.points[i][0], path.points[i][1]), new PVector(path.points[i+1][0], path.points[i+1][1]), temp.pos);
    if (distance < temp.footprint + path.pathWidth / 2.f) {
      return true;
    }
  }
  return false;
}

 public float pointSegmentDistance(PVector s1, PVector s2, PVector p) {
  //returns float value of the distance between line segment s1s2 and point p
  //theres a lot of math here that i barely understand so idk how to explain it in comment form
  //basically, we're centering the entire system to the origin, and getting the dot product of the line segment and the point.
  //if the dot product is greater than 1,


  PVector s1s2 = new PVector(s2.x - s1.x, s2.y - s1.y); //s1s2 is a line segemtn where point A is the origin, and point B is s2-s1.
  PVector s1p = new PVector(p.x - s1.x, p.y - s1.y);
  float len = dist(0, 0, s1s2.x, s1s2.y); //length of path
  float projection = constrain((s1s2.x * s1p.x + s1s2.y * s1p.y) / pow(len, 2), 0, 1);
  //strokeWeight(4);
  //stroke(0, 255, 0);
  //line(p.x, p.y, s1.x + projection * s1s2.x, s1.y + projection * s1s2.y);
  return dist(p.x, p.y, s1.x + projection * s1s2.x, s1.y + projection * s1s2.y);
}

 public void runShop() {
  noStroke();
  fill(MENU_COLOR);
  rect(width-MENU_WIDTH, 0, MENU_WIDTH, height);

  boolean[] pressed = new boolean[shopButtons.length];
  for (int i = 0; i < shopButtons.length; i++) {
    pressed[i] = shopButtons[i].pressed;
    shopButtons[i].run();
    shopButtons[i].display();

    //tower bought
    if (pressed[i] && !shopButtons[i].pressed && money >= shopButtons[i].cost) {
      placingTower = true;
      if (towerSelected) {
        purchasedTowers.get(towerSelectedIndex).selected = false;
        towerSelected = false;
        towerSelectedIndex = -1;
      }
      tempTower = shopButtons[i].tower.copy();
      tempTower.tSize = possibleTowers[i].tSize;
      tempTower.pos = new PVector(mouseX, mouseY);
      tempTower.placing = true;
    }
  }
}

 public void runTowersEnemies() {
  //calculate towers
  for (int i = 0; i < purchasedTowers.size(); i++) {
    purchasedTowers.get(i).run();
  }

  //calculate enemies
  for (int i = 0; i < spawnedEnemies.size(); i++) {
    spawnedEnemies.get(i).run();
    if (spawnedEnemies.get(i).reachedEnd) {
      lives -= spawnedEnemies.get(i).dmg;
      spawnedEnemies.remove(i);
      continue;
    }
    if (spawnedEnemies.get(i).health < 1) {
      spawnedEnemies.remove(i);
      continue;
    }
  }

  //display both
  for (int i = 0; i < spawnedEnemies.size(); i++) {
    spawnedEnemies.get(i).display();
  }
  for (int i = 0; i < purchasedTowers.size(); i++) {
    purchasedTowers.get(i).display();
  }
  for (int i = 0; i < purchasedTowers.size(); i++) {
    purchasedTowers.get(i).displayRadius();
  }
}
class BaseTower {
  boolean selected, placing;
  int dmg, pierce, projWidth, tSize, footprint, range, cost, dmgCount, invalidTime, fireFrame, fireRate, dmgCounter;
  int towerColor;

  String name;
  PImage image;
  PVector pos;
  Enemy target;
  ArrayList<Projectile> projectiles = new ArrayList<Projectile>();

  BaseTower(int dmg, int pierce, int projWidth, int range, int cost, int fireRate, String name) {
    this.dmg = dmg;
    this.pierce = pierce;
    this.projWidth = projWidth;
    this.range = range;
    this.cost = cost;
    this.name = name;
    this.fireRate = fireRate;
    tSize = TOWER_SIZE;
    footprint = TOWER_FOOTPRINT;
    fireFrame = -fireRate;
    pos = new PVector(0, 0);
    towerColor = BASE_TOWER_COLOR;
  }

   public void run() {
    if (placing) {
      pos.x = min(mouseX, width - MENU_WIDTH);
      pos.y = mouseY;
    } else {
      for (Projectile p : projectiles) {
        dmgCounter += p.run();
      }

      target = getTarget();

      //get rid of any dead projectiles
      for (int i = 0; i < projectiles.size(); i++) {
        if (projectiles.get(i).dead) {
          projectiles.remove(i);
        }
      }

      if (target != null) {
        if (frameCount - fireRate > fireFrame) { //delay is over, fire projectile
          fireFrame = frameCount;
          projectiles.add(new Projectile(pos, target.pos, dmg, pierce));
        }
      }
    }
  }

   public void display() {
    //text("target: " + target, 200, 200);
    //text("delayTimer: " + delayTimer, 200, 230);
    //text("projectiles: " + projectiles.size(), 200, 260);
    //println(projectiles.size());
    for (int i = 0; i < projectiles.size(); i++) {
      projectiles.get(i).display();
    }

    if (selected) {
      fill(255, 255, 0);
      text("popcount: " + dmgCounter, pos.x, pos.y + 50);
    }

    fill(towerColor);
    strokeWeight(1);
    stroke(0);
    circle(pos.x, pos.y, tSize * 2);
  }

   public void displayRadius(boolean force) {
    if (selected || placing || force) {
      displayRadius();
    }
  }

   public void displayRadius() {
    if (!(placing || selected)) return;
    if (placing) {
      if (invalidTime + INVALID_DELAY > millis()) {
        fill(INVALID_COLOR);
      } else {
        fill(PLACING_COLOR);
      }
    } else if (selected) {
      fill(RADIUS_COLOR);
    }
    noStroke();
    circle(pos.x, pos.y, range * 2);
  }

   public Enemy getTarget() {
    Enemy[] inRange = new Enemy[spawnedEnemies.size()];
    int counter = 0;
    for (int i = 0; i < spawnedEnemies.size(); i++) {
      if (dist(spawnedEnemies.get(i).pos.x, spawnedEnemies.get(i).pos.y, pos.x, pos.y) < range + spawnedEnemies.get(i).hitBox) {
        inRange[counter] = spawnedEnemies.get(i);
        counter++;
      }
    }

    if (counter == 0) return null;
    if (counter == 1) return inRange[0];

    //else return target with largest prog value
    float maxProg = 0;
    int maxProgIndex = 0;
    for (int i = 0; i < counter; i++) {
      if (inRange[i].prog > maxProg) {
        maxProg = inRange[i].prog;
        maxProgIndex = i;
      }
    }
    return inRange[maxProgIndex];
  }

   public BaseTower copy() {
    BaseTower toReturn = new BaseTower(dmg, pierce, projWidth, range, cost, fireRate, name);
    toReturn.pos = new PVector(pos.x, pos.y);
    toReturn.selected = placing;
    return toReturn;
  }
}
class Button {
  int w, h, c, b;
  boolean pressed;
  int borderColor, fillColor;

  PVector pos;
  PImage image;

  Button(int x, int y, int w, int h, int c, int b, int borderColor, int fillColor) {
    pos = new PVector(x, y);
    this.w = w;
    this.h = h;
    this.c = c;
    this.b = b;
    this.borderColor = borderColor;
    this.fillColor = fillColor;
  }

   public void display() {
    strokeWeight(b);
    stroke(borderColor);
    fill(fillColor);
    rect(pos.x, pos.y, w, h, c);
    //circle(pos.x, pos.y, w);
    //image(image, pos.x, pos.y);
    if (pressed) {
      fill(200, 200, 200, 50);
      noStroke();
      rect(pos.x, pos.y, w, h, c);
    }
  }

   public void run() {
    pressed = isPressed() && mousePressed;
  }

   public boolean isPressed() {
    return (mouseX >= pos.x + c && mouseX <= pos.x + w - c && mouseY >= pos.y - 0.5f * b && mouseY <= pos.y + h + 0.5f * b)
      || (mouseX >= pos.x - 0.5f * b && mouseX <= pos.x + w + 0.5f * b && mouseY >= pos.y + c && mouseY <= pos.y + h - c)
      || dist(pos.x + c, pos.y + c, mouseX, mouseY) <= c + 0.5f * b
      || dist(pos.x + w - c, pos.y + c, mouseX, mouseY) <= c + 0.5f * b
      || dist(pos.x + c, pos.y + h - c, mouseX, mouseY) <= c + 0.5f * b
      || dist(pos.x + w - c, pos.y + h - c, mouseX, mouseY) <= c + 0.5f * b;
  }
}
class DartMonkey extends BaseTower {
  DartMonkey() {
    super(1, 2, 3, TOWER_RANGE, 250, PApplet.parseInt(FRAMERATE * 0.8f), "Dart Monkey");

    //1 dmg, 2 pierce, 3 projWidth
  }
}
class Enemy {
  int dmg, size, health, hitBox;
  float prog, spd;
  PVector pos;
  boolean reachedEnd;

  Enemy(int health) {
    this.health = health;
    dmg = health;
    spd = ENEMY_BASE_SPEED + dmg * 0.5f;
    prog = 0;
    size = ENEMY_SIZE;
    hitBox = ENEMY_HITBOX;
    reachedEnd = false;

    pos = new PVector(0, 0);
  }

   public void run() {
    prog += spd;
    calculatePos();
  }

   public void display() {
    stroke(255);
    strokeWeight(2);
    fill(255, 255 * (PApplet.parseFloat(health) / ENEMY_MAX_HEALTH), 120 + 135 * (PApplet.parseFloat(health) / ENEMY_MAX_HEALTH));
    circle(pos.x, pos.y, size - 2);
    fill(255, 0, 0);
    //text(health, pos.x, pos.y - 2 * size / 3);
    text(this.toString().substring(this.toString().length() - 3), pos.x, pos.y - 2 * size / 3);
  }

   public void calculatePos() {
    float mprog = prog;
    int pathCounter = 0;
    while (mprog > path.lengths[pathCounter]) {
      mprog -= path.lengths[pathCounter];
      pathCounter++;
      if (pathCounter == path.lengths.length) {
        reachedEnd = true;
        return;
      }
    }
    //mprog is progess along its current path between two points
    pos.x = (mprog / path.lengths[pathCounter]) * (path.points[pathCounter+1][0] - path.points[pathCounter][0]) + path.points[pathCounter][0];
    pos.y = (mprog / path.lengths[pathCounter]) * (path.points[pathCounter+1][1] - path.points[pathCounter][1]) + path.points[pathCounter][1];
  }

   public Enemy copy() {
    return new Enemy(health);
  }
}
class Path { //a series of points that makes up the vertices of a path (straight line connections)
  int pathWidth = PATH_WIDTH;
  int[][] points = {
    {-100, 330},
    {603, 330},
    {603, 150},
    {400, 150},
    {400, 600},
    {370, 630},
    {220, 630},
    {200, 610},
    {200, 450},
    {730, 450},
    {760, 440},
    {770, 430},
    {780, 410},
    {780, 270},
    {920, 270},
    {910, 560},
    {540, 560},
    {540, height+100}
  };
  //int[][] points = {{0, 400}, {1000, 400}};

  int[] lengths = new int[points.length-1];

  Path() {
    for (int i = 0; i < points.length-1; i++) {
      lengths[i] = PApplet.parseInt(dist(points[i][0], points[i][1], points[i+1][0], points[i+1][1]));
    }
  }

   public void display() {
    strokeWeight(pathWidth);
    stroke(PATH_COLOR);
    for (int i = 0; i < points.length-1; i++) {
      line(points[i][0], points[i][1], points[i+1][0], points[i+1][1]);
    }
  }
}
class Projectile {
  int dmg, pierce, size, spd;
  float range;
  boolean dead;
  PVector pos, prevPos, vel;
  ArrayList<String> attackedEnemies = new ArrayList<String>();

  Projectile(PVector startPos, PVector targetPos, int dmg, int pierce) {
    pos = startPos.copy();
    prevPos = new PVector(0, 0);
    vel = PVector.sub(targetPos.copy(), startPos.copy());
    this.dmg = dmg;
    this.pierce = pierce;
    size = PROJ_SIZE;
    range = PROJ_RANGE;
    spd = PROJ_SPD;
    dead = false;
    vel.setMag(spd);
  }

   public int run() {
    int tempCounter = 0;
    prevPos = pos.copy();
    pos.add(vel);
    range -= vel.mag();
    if (range <= 0) {
      dead = true;
      return 0;
    }
    //check if it is colliding with any enemies
    for (int i = 0; i < spawnedEnemies.size(); i++) {
      boolean attacked = false;
      for (int j = 0; j < attackedEnemies.size(); j++) {
        if (attackedEnemies.get(j).equals(spawnedEnemies.get(i).toString())) { //ensures that each projectile can only hit an enemy once
          attacked = true;
          break;
        }
      }
      if (attacked) continue;
      if (pointSegmentDistance(prevPos, pos, spawnedEnemies.get(i).pos) < spawnedEnemies.get(i).size + size / 2) {
        spawnedEnemies.get(i).health -= dmg;
        pierce -= 1;
        tempCounter += dmg;
        attackedEnemies.add(spawnedEnemies.get(i).toString());
        money += dmg;
      }
      if (pierce <= 0) {
        dead = true;
        return tempCounter;
      }
    }
    return tempCounter;
  }

   public void display() {
    pushMatrix();
    translate(pos.x, pos.y);
    rotate(vel.heading());
    stroke(100, 255, 150);
    strokeWeight(size);
    line(-size, 0, size, 0);
    popMatrix();
  }
}
class ShopButton extends Button {
  int cost;
  BaseTower tower;

  ShopButton(BaseTower tower, int x, int y, int cost, int w, int h) {
    super(x, y, w, h, 6, 2, color(255, 255, 255, 100), color(120, 120, 102));
    this.tower = tower;
    this.cost = cost;

    //image = tower.image.copy();
    //image.resize(w, h);
  }

  @Override public 
    void display() {
    super.display();
    tower.display();
    if (money < cost) {
      noStroke();
      fill(color(0, 0, 0, 150));
      rect(pos.x, pos.y, w, h, c);
    }
    fill(0);
    text(tower.name, pos.x, pos.y + h / 2);
  }
}


  public void settings() { size(1420, 780); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TowerDefense" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
